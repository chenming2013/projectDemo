多线程：
	一、
		1、什么是程序？
			程序是指安装在磁盘上的一段指令集和，它是静态的概念。
		2、什么是进程？
			进程是程序的一次执行过程，或者是正在运行的一个程序、是动态的概念(一个程序运行起来就会有一个进程)。每个进程都有独立的资源空间
		3、什么是线程？
			线程，又称为轻量级进程，是程序执行流的最小单元，是程序中一个单一的顺序控制流程。
			线程是进程中的一个实体，是被系统独立调度和分派的基本单位。
		4、什么是多线程？
			多线程则指的是在单个程序中可以同时运行多个不同的线程执行不同的任务。
	
	
	二、进程与线程：
		1、进程在操作系统的定义中是指程序的一次完整运行，在这个运行之中，内存、处理器、IO等资源操作都要为这个进程服务。
		   Windows属于多进程的操作系统，那么每一个进程都需要有资源的支持，那么多个进程怎么去分配资源呢？
		      在同一个时间段上，会有多个进程轮流去抢占资源，但是在某个时间点上，只会有一个进程运行。
		      而且系统会为每个线程一小段CPU时间片，一旦CPU时间片结束就会将当前线程切换为下一个线程，即使改线程没有结束。
		      即：在当前线程的一小段CPU时间片上，该线程执行抢占到的资源，若是CPU时间片结束，不管有没有执行完抢占到的资源，系统都会切换到下一个线程。
		      
		      线程是在进程的基础上进一步划分的结果，即：一个进程上可以同时创建多个线程。
		      线程是比进程更快的处理单元，而且所占的资源也小。那么多线程的应用也就是性能最高的应用。
		      线程的存在离不开 进程。进程消失后，线程一定消失；反之如果线程消失了，进程不一定消失。
		2、许多活动可以同时执行，这种思想在Java中被称为并发，而将并发完成的每一件事称为线程。
		3、一个进程是一个包含有自身地址的程序，每个独立执行的程序都称为进程，也就是正在执行的程序。
		4、系统可以分配给每个进程一段有限的使用CPU的时间（也可以称为CPU时间片），CPU在这段时间中执行某个进程，然后下一个时间片又调至另一个进程中去执行。
		5、一个线程则是进程中的执行流程，一个进程中可以同时包括多个线程，每个线程也可以得到一段程序的执行时间，这样一个进程就可以具有多个并发执行的线程。
	   	     在单线程中，程序代码按调用顺序依次往下执行，如果需要一个进程同时完成多段代码的操作，就需要产生多线程。
	   	     
	  
	三、多线程的特点：
		1、一个进程可以包含一个或多个线程
		2、一个程序实现多个代码同时交替运行就需要产生多个线程
		3、线程本身不拥有系统资源，而是与同属一个进程的其他线程共享所在进程所拥有的资源（即：系统为进程分配资源，进程里的多个线程共同分享这个资源） 
		4、同一进程中的多个线程之间可以并发执行。CPU会随机抽出时间让我们的程序一会做这件事情、一会做另一件事情。
	
	
	四、多线程的目的：
		“最大限度的利用CPU资源”，当某一线程的处理不需要占用CPU而只和I/O等资源打交道的时候，让需要占用CPU资源的其它线程有机会获得CPU资源。从根本上来说，这就是多线程编程的最终目的。
	
	
	五、实现多线程的两种方法
		1、继承Thread类：【观察：MultiThreadDemo1_1.java/MultiThreadDemo1_2.java】
			Thread类是一个支持多线程的功能类，如果一个类继承了Thread类，那么这个类就成为了线程类。	
			所有程序的起点是main()方法，而所有的线程的起点就是run()方法，在多线程的每个主类之中都必须重写Thread类提供的run()方法。
			public void run(): run()方法没有返回值，表明线程一但开始就要一直执行，不能有返回内容。
			【注意】：调用start()方法，JVM会执行该线程的run()方法
			【疑问】：为什么多线程启动不是调用run()而必须调用start()？
			  我们先来看一下start()方法的源代码：
			  public synchronized void start() 
			  {
        			if (threadStatus != 0)  //如果线程启动不等于0次
            			throw new IllegalThreadStateException();
        			group.add(this);
       				start0();
        			if (stopBeforeStart)
        			{
	    				stop0(throwableFromStop);
					}
    		  }
    		  private native void start0();
    		  /*
    		  1、首先发现在start()方法里面存在 “IllegalThreadStateException” 异常。本方法里面使用了throw抛出 “IllegalThreadStateException” 异常，按照道理来讲
    		          应该使用try...catch处理，或者是start()方法声明上使用throws声明，但此处并没有这样的代码，因为此异常属于RuntimeException的子类，现在来看一下 “IllegalThreadStateException” 异常：
    		     IllegalThreadStateException ：如果线程已经启动的话，那么多次启动一个线程是非法的，此时就会报这个异常，即：一个线程只能调用一次start()方法。
    		  2、发现在start()方法调用了start0()方法，而start0()方法的结构与抽象方法类似，唯一不同的是使用native声明。
    		          在Java开发技术有一门技术称为JNI（Java native interface）技术，这门技术的特点是：使用Java调用本机操作系统提供的函数。
    		          但是这个技术有一个缺点，那就是不能离开特定的操作系统，那为什么又要有这门技术呢？
    		          这是因为如果要想多线程能够执行，那么就必须抢占资源，而这就需要操作系统来进行资源分配，所以start0()方法此操作严格来讲是由JVM根据不同的操作系统来实现的。
    		    总结：使用Thread类的start()方法不仅仅要启动多线程的执行代码，还要去根据不同的操作系统进行资源的分配。
    		  */
		2、实现Runnable接口：【观察：MultiThreadDemo2_1.java/MultiThreadDemo2_2.java】
			虽然Thread类可以实现多线程的主题类定义，但是它有一个问题，Java具有单继承局限，正因为如此，在任何情况下针对类的继承，都应该是回避的问题，那么多线程也一样。
			所以为了解决单继承的限制，在Java里面专门提供了Runnable接口。
			与继承Thread类相比，此时的MyThread2类在结构上与之前是没有区别的，但是有一点是有严重区别的，如果是继承Thread可，那么就可以直接继承start()方法，但是如果是实现Runnable接口，并没有start()方法可以被继承
			那么此时应该怎么办呢？
			我们强调过，不管何种情况下，如果想启动多线程就一定要依靠Thread类中的start()方法，在Thread类里面定义有以下的构造方法：
			构造方法：public Thread(Runnable target),接收的是Runnable接口对象.
			使用Runnable接口比Thread类可以更能反映出数据共享这一概念，此时的数据共享指的是多个线程访问同一资源的操作。
			
		3、面试题：请解释Thread类与Runnable接口实现多线程的区别？
			1、Thread类是Runnable接口的子类，实现Runnable接口实现多线程可以避免单继承局限。
			2、Runnable接口实现的多线程可以比Thread类实现的多线程更加清楚的描述数据共享的概念


	六、我们可以知道，线程实际上一直都存在，因为一个主方法就是一个主线程，其它在主方法中定义的线程都是子线程，既然如此，那么进程又去哪里了呢？
	       通过操作我们可以知道，每当使用Java命令去解释一个程序类的时候，对于操作系统而言，都相当于启动了一个新的进程，而main只是这新进程上的一个子线程而已。
	       提问：每一个JVM进程启动的时候至少启动几个线程？
	         1.mian线程：程序的主要执行，以及启动子线程
	         2.gc线程：负责垃圾收集

	六、Thread类常用方法：【注意：主方法也算是一个线程】
		1.start():启动线程并执行相应的run()方法。
		2.run():子线程要执行的代码放入run()方法中。
		3.currentThread()：静态的，调取当前的线程。
		4.getName()：获取此线程的名字。
		5.setName():设置此线程的名字。
		6.yield():调用此方法的线程释放当前CPU的执行权。
		7.join():在A线程中调用B线程的join()方法，表示当执行到此方法的时候，A线程停止执行，直至B线程执行完毕，A线程再接着join()之后的代码执行。【观察：MultiThreadDemo8.Java】
		8.isAlive():判断当前线程是否还存活。
		9.sleep(long time):显式的让当前线程睡眠time毫秒。【观察：MultiThreadDemo7.Java】
		10.线程通信：wait()、notify()、notifyAll()
		11.设置线程优先级：
			getPriority():返回线程优先值
			setPriority(int newPriority):改变线程 的优先级
		12.interrupt():中断当前线程
	七、线程声明周期，也是线程状态
		与人有生老病死一样，线程同样需要经历新建、就绪、运行（活动）、阻塞、死亡五种不同的状态。这五种状态都可以通过Thread类中的方法来进行控制。
		1）新建状态：在Java语言中使用new操作符创建一个线程后，该线程仅仅是一个空对象，它具备了线程的一些特征，但此时系统没有为其分配资源，这时的线程处于创建状态。
		                       线程处于创建状态时，可通过Thread类中的方法来设置各种属性，如线程的优先级（setPriority）、线程名（setName）、线程类型（setDaemon）等等。
		                       【注：线程优先级越高，这个线程被CPU执行的概率越是大；线程类型主要分为用户线程和守护线程（后台线程），当所有的用户线程结束了，那么守护线程也就结束了，最典型的守护线程就是垃圾回收器中的线程。】
		2）就绪状态：使用start()方法启动一个线程后，系统为该线程分配了除CPU外的所需资源，使该线程处于就绪状态。此外，如果某个正在执行的线程执行了yield()方法，那么该正在执行的线程就会主动放弃CPU资源，就会重新进入就绪状态。
		3）运行状态：Java运行系统通过调度选中一个处于就绪状态的线程，使其占有CPU并转为运行状态。此时，系统真正执行线程的run()方法。
			               可以通过Thread类的isAlive()方法来判断线程是否处于就绪/运行状态；当线程处于就绪/运行状态时，isAlive()方法返回true，当isAlive()犯法返回false时，可能线程处于阻塞状态，也可能处于停止状态。
	    4）阻塞状态：一个真正运行的线程因某些原因不能继续运行时，就进入阻塞状态。这些原因包括：
	    		    ①当执行了某个线程对象的sleep()等阻塞类型的方法时，该线程会被置于一个阻塞集（Blocked Pool）内，等待超时而自动苏醒。
	    		    ②当多个线程试图进入某个同步区域（synchronize）时，没能进入该同步区域的线程会被置入锁定集（Lock Pool），直到获得该同步区域的锁，进入就绪状态。
	    		    ③当线程执行了某个对象的wait()方法时，线程会被置入该对象的等待集（Wait Pool）中，直到执行了该对象的notify()方法，wait()/notify()方法的执行，首先要求线程获取该对象的锁。
	    5）死亡状态：线程在run()方法执行结束后进入死亡状态。此外，如果线程执行了interrupt()方法或stop()方法，那么它也会以异常退出的方式进入死亡状态。
	    
	    
	八、终止线程的三种方法：
		1）使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。（推荐使用）
		2）使用stop方法强制终止线程，（不推荐使用，因为stop和suspend、resume一样，也可能发生不可预料的结果）
		3）使用interrupt方法中断线程
		
		
	九、线程同步   【观察：MultiThreadDemo4_1.java/MultiThreadDemo4_2.java】
		1）为什么需要同步？
			1、线程同步是为了防止多个线程访问一个数据对象时，对数据造成该破坏。也就是说同一时间内只有一个线程去操作这个数据，不能发生同一段时间内多个线程操作同一个数据。
			2、线程同步是保证多线程安全访问竞争资源的一种手段。
		2）同步和锁
			1、Java中每个对象都有一个内置锁。
			2、当程序运行到非静态的synchronize同步方法上时，自动获得与正在执行代码类的当前实例（this实例）有关的锁；当程序运行到synchronize同步代码块时，自动获得锁定对象的锁。
			3、获取一个对象的锁也称为获取锁、锁定对象、在对象上锁定或在对象上同步。当程序运行到synchronize同步方法或代码块时，该对象锁才起作用。
			4、一个对象只有一个锁。所以如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放锁。这也意味着任何其他线程都不能进入synchronize方法或代码块，直到该锁被释放，释放锁是指持锁线程synchronize同步方法或代码块。
		3）对于同步，一般而言在Java代码中需要完成两个操作。 
			1、确定多个线程的共享资源（如打印十次、取800元），并把这个共享资源声明为private
			2、同步那些访问资源的代码，使用synchronize关键字来修饰方法或代码块。当synchronize方法执行完或发生异常时，会自动释放锁。
			【注意：同步要想实现，必须多个线程共用一把锁,即过个线程公用一个资源。】
			
	十、线程存在安全问题的原因：
		由于一个线程在操作共享数据过程中，未执行完毕的情况下，另外的线程参与进来，导致共享数据存在了安全问题。
		
		
	十一、同步产生死锁的原因【参考MultiThreadDemo5.java】
		当一个线程已经获取对象一的锁，同时又想获取对象二的锁。而与此同时，另一个线程当前已经持有对象二的锁，而又想获取对象一的锁。这种互相等待对方释放锁的过程，会导致“死锁”。
		
			
	十二、线程通信：【观察：MultiThreadDemo6.Java】
		1.wait():调用wait()方法可以使调用该方法的线程释放共享资源的锁，然后从运行状态退出，进入等待队列，直到被再次唤醒。
		2.notify():调用notify()方法可以唤醒等待队列中第一个等待同一共享资源的线程，并使该线程退出等待队列，进入可运行状态。
		3.notifyAll():调用notifyAll()方法可以使所有正在等待队列中同一共享资源的线程从等待状态退出，进入可运行状态。
	
	
	十三、注意问题
		1、当一个线程调用同步方法或者同步代码就会获得当前对象的锁，若是方法中有Thread.sleep()操作，只会让该线程睡眠，但并不会释放锁，所以其他的线程仍然是无法获得该锁。
		     只有当该线程完全执行完毕，释放锁，另外的线程才能开始执行。
			
			
			问题：Thread.sleep（）让一个线程休息，那么该线程是否释放资源？---->释放资源，但是不释放锁
			问题：在死锁的时候，如果两个线程睡眠的时间不一样，甚至差距很大，大到
			问题：死锁产生是两个线程互相等待对方释放锁，但是一个线程已经抢占了CPU，另一个线程无法执行，又怎么释放资源？
			问题：如果一个线程执行了synchronize声明的方法或代码块，那是不是要等到这个线程执行完，下个线程才能开始执行？
		
	
	