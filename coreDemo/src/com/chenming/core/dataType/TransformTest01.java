package com.chenming.core.dataType;

/**
 * 测试基本数据类型转换
 * @author Lenovo
 *	
 *	类型转换分为自动转换(隐式转换)和强制转换(显式转换)
 *		自动转换:分两种情况：
 *			1.常量赋值给变量：(常量默认是int或者double类型,这里以int为例)
 *				1)常量值赋值给表值范围比int大的变量：
 *					-进行了自动类型转换,将常量的类型转换成了表值范围大的类型(向上转换总是自动,并且安全的)
 *				2)常量值赋值给表值范围比int小的变量：
 *					①常量值没有超出变量类型的取值范围：
 *						-进行了自动类型转换(向下转型),将常量的类型转换成了变量的类型
 *					②常量值超出了变量类型的取值范围：
 *						-编译报错,若想不报错,就要使用强制转换,但是会丢失精度	
 *			2.变量赋值给变量：
 *				1)变量赋值给比它自己的类型的表值范围大的变量：
 *					-进行了自动类型转换,将变量的类型向上提升了(向上转型总是自动,并且安全的)
 *				2)变量赋值给比它自己的类型的表值范围小的变量：(这种情况下都是要强制转换的,而且都会丢失精度,区别在于变量的值是否发生了变化)
 *					①变量的值没有超出要赋给的变量的表值范围：
 *						-需要进行强制类型转换,否则会报错,变量的值不变
 *					②变量的值超出了要赋给的变量的表值范围：
 *						-需要进行强制类型转换,否则会报错,变量的值变了
 */
public class TransformTest01
{
	public static void main(String[] args)
	{
		/**
		 * 常量赋值给变量
		 */
		// 1.>1) 常量值(2)赋值给表值范围比int大的变量(a),进行了自动类型提升,不会丢失精度
		long a = 2;
		
		// 2.>2)>① 常量值(100)赋值给表值范围比int小的变量(b),此时因为100的值在byte类型的表值范围之中(-128~127),不会报错,但会发生向下转型,而且会丢失精度
		byte b = 100;
		// 2.>2)>② 常量值(200)赋值给表值范围比int小的变量(c),此时因为200的值超出了byte类型的表值范围,所以需要强制类型转换,否则会报错,而且转换之后会丢失精度
		byte c = (byte)200;
		
		
		/**
		 * 变量赋值给变量
		 */
		int d = 10;
		// 2.>1) 变量(d)赋值给比int(d的类型为int)类型表值范围大的类型(long),会自动向上转型,且不会丢失精度
		long e = d;
		
		// 2.>2)>① 变量(d)赋值给比int(d的类型为int)类型表值范围小的类型(byte),此时肯定需要强制类型转换,否则会报错,
		//但因为d的值(10)在byte的取值范围之内,所以变量f的值等于变量d的值,也就是10
		byte f = (byte)d;
		System.out.println("f="+f);  //f=10
		
		// 2.>2)>② 变量(g)赋值给比int(g的类型为int)类型表值范围小的类型(byte),此时肯定需要强制类型转换,否则会报错,
		//又因为g的值(200)超出了byte类型的表值范围,所以变量h的值就不等于变量g的值了
		int g = 200;
		byte h = (byte)g;
		System.out.println("h="+h);  //h=-56
		
	}
}
